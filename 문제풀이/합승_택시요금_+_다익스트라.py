# -*- coding: utf-8 -*-
"""합승 택시요금 + 다익스트라.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sawRRy55dm8Xz0NB5WkDhDhXq3ES271o
"""

# 경로에 가중치 있을 경우 -> 바로 다익스트라 떠올리기

# 다익스트라

# 그래프 구현

import collections

graph = collections.defaultdict(dict)

graph = {
    'A' :{'B':8 , 'C':1 , 'D':2} ,
    'B' : {} ,
    'C' : {'B':5, 'D':2} ,
    'D' : {'E':3 , 'F':5} ,
    'E' : {'F':1} ,
    'F' : {'A': 5}   
}

import heapq

distances = {node: float('inf') for node in graph}

start='A'

# 모든 노드에 대해 inf 로 거리 초기설정 
distances

distances[start] = 0 # 시작지역 'A'로 할당

queue = []

# 큐에 가장 처음 갈곳 밀어넣기
heapq.heappush(queue, [distances[start],start]) # 지금 이 케이스 같은경우에 처음 스타트라 거리는 0 , 시작지역 'A' 가 들어가게 됨.

while queue:
  current_distance , current_destination = heapq.heappop(queue) # 가야 될 곳 꺼내와서  거리 , 현재위치에서 다음 갈 목표에 current_distance , current_destination 

  if distances[current_destination] < current_distance: # 가야 할 경로를 꺼내와서 업데이트를 하려고 봤더니  더 오래걸려 그러면 패스 ex) 시작시 무한 < 0 이어서 무조건 업데이트 하는게 나아서 다음 단계로
    continue 
  
  for new_destination, new_distance in graph[current_destination].items(): # 현재 위치에서 다음 갈곳을 후보에 넣어서 for문 돌리고  
    print(current_destination, current_distance ,"current")
    print(new_destination, new_distance ,"new")
    distance = current_distance + new_distance                             #  distance = current_distance( 현재까지 누적 거리 ) + new_distance( 다음위치까지의 거리 )
    if distance < distances[new_destination]:                              #  이 새로 구한 distance가 사전에 있는 값보다 작으면 사전을 업데이트
      distances[new_destination] = distance
      heapq.heappush(queue, [distance, new_destination])  # 갈 곳 추가       # 새로 갈곳을 이제 큐에 넣음 그리고 그담에 반복

distances



def dijkstra(graph, start):
  distance = {node: float('inf') for node in graph}
  distance =

n= 6
s = 4
a =6
b =2
fares = [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]]



INF = int(1e9)                                  #무한을 의미하는 값 10억 설정
graph = [[INF] * n for _ in range(n)]			
for i in range(n):                              #자기 자신으로 가는 비용 0
  graph[i][i] = 0
for i in fares:
  graph[i[0] - 1][i[1] - 1] = i[2]            #이동 방향에 따라 비용이 달라지지 않으므로
  graph[i[1] - 1][i[0] - 1] = i[2]

graph

for t in range(n):
    for i in range(n):
      for j in range(i, n): # 0 - 0,1,2,3,4,5 /  1- 1,2,3,4,5,/ 2,3,4,5 / 3,4,5                  
        if i != j:                          #최소 비용 계산
          temp = min(graph[i][j], graph[i][t] + graph[t][j])  # i-j 바로 연결과 어느 곳을 경유 했을 경우를 비교해서 작은 값을 넣는 과정이군.
          graph[i][j] = graph[j][i] = temp

graph

def solution(n, s, a, b, fares):

  # 그래프 세팅 하는 부분
  INF = int(1e9)                                  #무한을 의미하는 값 10억 설정
  graph = [[INF] * n for _ in range(n)]			
  for i in range(n):                              #자기 자신으로 가는 비용 0
    graph[i][i] = 0
  for i in fares:
    graph[i[0] - 1][i[1] - 1] = i[2]            #이동 방향에 따라 비용이 달라지지 않으므로
    graph[i[1] - 1][i[0] - 1] = i[2]			       # 이건 양방향으로 그래프를 만든거임


  # 이 3중 루프에서 graph 업데이트 

  for t in range(n):
    for i in range(n):
      for j in range(i, n): # 0 - 0,1,2,3,4,5 /  1- 1,2,3,4,5,/ 2,3,4,5 / 3,4,5                  
        if i != j:                          #최소 비용 계산
          temp = min(graph[i][j], graph[i][t] + graph[t][j])  # i-j 바로 연결과 어느 곳을 경유 했을 경우를 비교해서 작은 값을 넣는 과정이군.
          graph[i][j] = graph[j][i] = temp
  
  # 이제 최소값 찾는과정 
  # S-T , T-A , T-B 로 구분하기
  answer = INF
  for t in range(n):                              #경유점에 따라 최소 합승 비용 탐색
    temp = graph[s - 1][t] + graph[t][b - 1] + graph[t][a - 1]      
    answer = min(answer, temp)
  return answer